import transport
import encryption
import Crypto.Random
import json


class Event:
    def __init__(self, context):  # The context here is just the parameters of the event (the contents of a message,
        # the data in a file)
        self.context = context

    def handle(self):  # For children of this class, this will contain the code for handling the respective event
        pass


class Log(Event):  # An event which will be used for testing purposes
    def handle(self):  # It simply prints out its context
        print(self.context)


class Heartbeat(Event):  # An event which performs a heartbeat with a client
    def handle(self):
        client = self.context[0]
        transport.sendDynamicData(self.context[1], "heartbeatResponse", "none", client.clientSock, client.AESKey)


class Message(Event):  # An event for handling messages given to the client
    def handle(self):
        groupClients = self.context[0]
        data = self.context[1]
        currentClient = self.context[2]
        encoding = self.context[3]
        data = data.decode(encoding)
        messageAndToken = json.loads(data)
        token = json.loads(messageAndToken["sessionToken"])
        if token != currentClient.sessionToken:  # If the tokens don't match,
            currentClient.resetToken()  # Log the user out
        clientID = currentClient.sessionToken["id"]
        toSave = {"group": currentClient.sessionToken["groupID"],
                  "message": {
                      "sender": json.dumps({"id": clientID, "username": currentClient.username}),
                      "message": messageAndToken["message"]
                  }}  # Formats the message for saving to the message storage
        currentClient.messageStorage.putMessage(toSave)  # Save the message to the storage
        message = f"{currentClient.username}: {messageAndToken['message']}"  # Formats the message so that it
        # includes not only the message, but the user who said it
        clients = groupClients[currentClient.sessionToken["groupID"]]  # Gets a list of clients in the group
        for client in clients:
            transport.sendDynamicData(message.encode("utf-8"), "message", 'utf-8', client.clientSock,
                                      client.AESKey)  # Send the message to all clients in the group


class RetrieveMessages(Event):
    def handle(self):
        client = self.context[0]
        messages = self.context[1]
        group = client.sessionToken["groupID"]
        try:
            relevantMessages = messages.getMessages()[group]  # Get a list of messages in the required group
        except KeyError:
            return None  # If there aren't any messages, do nothing
        messageList = []
        for i in relevantMessages:
            userInfo = json.loads(i["sender"])  # Load info about the user (ID, username)
            messageList.append(f"{userInfo['username']}: {i['message']}")  # Format the message
        toBeSent = json.dumps(messageList)  # Dumps the entire message list into one string
        transport.sendDynamicData(toBeSent.encode("utf-8"), "retrievedMessages", "utf-8", client.clientSock,
                                  client.AESKey)  # Send this to the client


class NewAccount(Event):  # An event for handling new accounts
    def handle(self):
        storageMethod = self.context[0]
        client = self.context[1]
        username = self.context[2]
        password = self.context[3]
        userID = storageMethod.addUser(username, encryption.hashStringWithArgon(
            password))  # Add the username and the hashed password
        storageMethod.addUserToGroup(userID, 1)  # Add the user to the default group
        sessionTokenBytes = Crypto.Random.get_random_bytes(32).hex()  # Generates a 32-byte session token
        client.sessionToken["randomBytes"] = sessionTokenBytes
        client.sessionToken["id"] = userID  # Sets the ID to the one generated by SQL
        client.username = username  # Caches the username
        toSend = json.dumps({"newToken": json.dumps(client.sessionToken)})
        transport.sendDynamicData(toSend.encode("utf-8"), "newToken", "utf-8", client.clientSock,
                                  client.AESKey)  # Sends the session token to the client


class Login(Event):
    def handle(self):
        storageMethod = self.context[0]
        client = self.context[1]
        userInfo = self.context[2]
        password = self.context[3]
        clients = self.context[4]
        userIDs = [i.sessionToken["id"] for i in
                   clients]  # Gets a list of user IDs which are currently connected
        userID = userInfo.split(":")[1]  # Gets the user's ID from the entered username:ID format
        username, hashedPassword = storageMethod.getUser(
            userID)  # Retrieves the user's name and hashed password from the database
        sessionTokenBytes = Crypto.Random.get_random_bytes(32).hex()  # Generates a session token
        if encryption.verifyHashWithArgon(hashedPassword, password) and userID not in userIDs:
            client.sessionToken["randomBytes"] = sessionTokenBytes  # If the password is correct, give the client the
            # token
            client.sessionToken["id"] = userID
            client.username = username  # Caches the username
        else:
            client.resetToken()
            client.username = 'Guest'
        toSend = json.dumps({
            "newToken": json.dumps(
                client.sessionToken)})  # JSON is used because it is possible for the server to send nothing,
        # which would otherwise cause an error.
        transport.sendDynamicData(toSend.encode("utf-8"), "newToken", "utf-8", client.clientSock,
                                  client.AESKey)  # Sends the session token to the client


class Logout(Event):
    def handle(self):
        client = self.context[0]
        client.resetToken()


class MakeGroup(Event):
    def handle(self):
        client = self.context[0]
        groupName = self.context[1]
        storageMethod = self.context[2]
        groupID = storageMethod.addGroup(groupName)  # Uses the database to create the new group
        toSend = {"groupID": groupID}
        toBeSent = json.dumps(toSend)
        transport.sendDynamicData(toBeSent.encode("utf-8"), "groupID", "utf-8", client.clientSock, client.AESKey)
        # Sends the client the new group's ID
        if client.sessionToken["id"] != "0":  # If the client is logged-in,
            userID = client.sessionToken["id"]
            storageMethod.addUserToGroup(userID, groupID)  # Add them to the group


class GroupSwitch(Event):
    def handle(self):
        client = self.context[0]
        groupID = self.context[1]
        groupClients = self.context[2]
        eventQueue = self.context[3]
        if int(client.sessionToken["id"]) not in client.storageMethod.getUsersFromGroup(groupID):
            client.showMessage("\nError! You are not in the group!")  # If the user is not in the group, send an
            # Error message and quit.
            return None
        if client in groupClients[client.sessionToken["groupID"]]:
            groupClients[client.sessionToken["groupID"]].remove(client)  # Remove the client from their current group
        try:
            groupClients[groupID].append(client)  # And add them to the new one
        except KeyError:
            groupClients[groupID] = [client]
        client.sessionToken["groupID"] = groupID  # Otherwise, change the client's groupID
        transport.sendDynamicData(json.dumps(client.sessionToken).encode("utf-8"), "changeToken", "utf-8",
                                  client.clientSock, client.AESKey)  # And tell the client
        if not client.isAPI:  # If the client is not an API,
            eventQueue.put(RetrieveMessages([client, client.messageStorage]))  # Retrieve messages


class ListGroups(Event):
    def handle(self):
        client = self.context[0]
        token = self.context[1]
        storageMethod = self.context[2]
        if token != client.sessionToken:  # If the client has not logged in properly,
            client.resetToken()  # Log them out
            return None
        clientID = client.sessionToken["id"]
        groups = storageMethod.getGroupsFromUser(clientID)  # Get all the groups which the client is in
        groupNames = [storageMethod.getGroup(i) for i in groups]  # Get all the groups' names
        toSend = []
        for i in range(len(groups)):
            group = groups[i]
            groupName = groupNames[i]
            toSend.append(f"{groupName}:{group}")
        transport.sendDynamicData(json.dumps(toSend).encode("utf-8"), "listOfGroups", "utf-8", client.clientSock,
                                  client.AESKey)  # Send the client a list of group names and IDs


class LeaveGroup(Event):
    def handle(self):
        client = self.context[0]
        token = self.context[1]
        groupID = self.context[2]
        storageMethod = self.context[3]
        groupClients = self.context[4]
        eventQueue = self.context[5]
        if str(groupID) == "1":  # Make sure the user doesn't leave the default group
            client.showMessage("\nError! You cannot leave the default group!")
            return None
        if token != client.sessionToken:  # If there is an issue with authentication,
            client.resetToken()  # Force a log-out
            return None
        storageMethod.removeUserFromGroup(token["id"], groupID)
        if groupID == token["groupID"]:  # If the user was in this group,
            switchGroup = GroupSwitch([client, "1", groupClients, eventQueue])
            eventQueue.put(switchGroup)  # Switch them to the default group


class AddUserToGroup(Event):
    def handle(self):
        client = self.context[0]
        userID = self.context[1]
        groupID = self.context[2]
        storageMethod = client.storageMethod
        clientID = client.sessionToken["id"]
        if int(groupID) not in storageMethod.getGroupsFromUser(clientID):  # If the user is not in the group,
            client.showMessage("\nError! You are not in the group!")  # Send an error message and quit.
            return None
        # If the user is in the group,
        client.showMessage(f"\nSuccessfully added user {userID} to group {groupID}")  # Send a success message
        storageMethod.addUserToGroup(userID, groupID)  # If they are, add the required user to the group.


class SaveMessage(Event):
    def handle(self):  # Saves a dictionary of messages to a file
        messagesToSave = self.context
        AESKey = encryption.generateKey()  # Make a new random AES Key for encrypting the messages
        encryption.writeAESKey("AES.key", AESKey)  # Save the AES Key
        encryption.writeEncryptedJSON("messages.enc", AESKey, messagesToSave)  # Encrypt and save the messages
